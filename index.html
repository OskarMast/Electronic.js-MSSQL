<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Richmond System</title>
    <style>
        .noborder { border: none; }
        .input--medium { width: 200px; }
        #period-from-to { display: none; } /* Initially hide the period-from-to section */
        #period_table { margin-top: 15px; margin-bottom: 15px;}
    </style>
    <style>
        table {
            border: 1px solid #ccc;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
            height: 24px;
        }

        th {
            background-color: #f2f2f2;
        }
    </style>
    <style>
        /* Style for the select element */
        #data-select {
            padding: 10px; /* Add padding */
            font-size: 16px; /* Increase font size */
            width: 120px; /* Set width */
        }

        #data-format-select {
            padding: 10px; /* Add padding */
            font-size: 16px; /* Increase font size */
            width: 250px; /* Set width */
        }
    
        /* Style for buttons */
        button {
            padding: 10px 20px; /* Add padding */
            font-size: 16px; /* Increase font size */
            margin: 10px 10px; /* Space between buttons */
            cursor: pointer; /* Change cursor on hover */
        }

    </style>
    <style>
        body { font-family: Arial, sans-serif; }
        #output { white-space: pre-wrap; background: #f4f4f4; padding: 10px; border: 1px solid #ccc; }
        /* table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; } */
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <h1>Richmond System</h1>
    
    <label for="data-select">Select Data Source:</label>
    <select id="data-select" onchange="fetchTableFormats()"></select>
    <select id="data-format-select" onchange="getTableData()"></select>

    <button id="export-pdf">Export to PDF</button>
    <button id="export-csv">Export to CSV</button>

    <table id="period_table">
        <tr id="graph-period" class="noborder">
            <th class="cell--default">Period</th>
            <td>
                <div class="input__radio-2__wrap">
                    <input type="radio" checked="checked" class="input__radio-2" id="period-day" value="OneDay" name="period">
                    <label for="period-day">1 Day</label>
                    
                    <input type="radio" class="input__radio-2" id="period-week" value="OneWeek" name="period">
                    <label for="period-week">1 Week</label>
                    
                    <!-- <input type="radio" class="input__radio-2" id="period-month" value="OneMonth" name="period">
                    <label for="period-month">1 Month</label>
                    
                    <input type="radio" class="input__radio-2" id="period-half-year" value="HalfYear" name="period">
                    <label for="period-half-year">6 Months</label>
                    
                    <input type="radio" class="input__radio-2" id="period-year" value="OneYear" name="period">
                    <label for="period-year">1 Year</label>
                    
                    <input type="radio" class="input__radio-2" id="period-custom" value="Custom" name="period">
                    <label for="period-custom">Custom</label> -->
                </div>
            </td>
            <td></td>
        </tr>
    
        <tr id="period-from-to">
            <th></th>
            <td>
                <input value="2024-08-18T00:00" class="input input--text input--medium" id="PeriodFrom" name="PeriodFrom" type="datetime-local">
                <span class="field-validation-valid" data-valmsg-for="PeriodFrom"></span>
                -
                <input value="2024-08-19T10:00" class="input input--text input--medium" id="PeriodTo" name="PeriodTo" type="datetime-local">
                <span class="field-validation-valid" data-valmsg-for="PeriodTo"></span>
                <!-- <button class="btn btn--low column__box--solo" type="button" id="btn__get-graph">Confirm</button> -->
            </td>
            <td></td>
        </tr>
    </table>    

    <div id="output"></div>
    <div id="chart-container"></div>
    <script>
       
        const { connectToDatabase, queryDatabase } = require('./db');
        // Declare outputDiv at the top
        const outputDiv = document.getElementById('output');
        const fetchTableNames = async () => {
            try {
                await connectToDatabase();
                const tables = await queryDatabase("SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';");
                const selectElement = document.getElementById('data-select');
                const filteredTables = tables.filter(table => table.TABLE_NAME.endsWith('_data'));

                // Populate the select element with filtered table names
                filteredTables.forEach(table => {
                    const option = document.createElement('option');
                    option.value = table.TABLE_NAME;
                    option.textContent = table.TABLE_NAME;
                    selectElement.appendChild(option);
                });

                selectElement.innerHTML = '';
                filteredTables.forEach(table => {
                    const tableName = table.TABLE_NAME.replace(/^cMT-4429_/, '').replace(/_data$/, '');
                    const option = document.createElement('option');
                    option.value = table.TABLE_NAME;
                    option.textContent = tableName;
                    selectElement.appendChild(option);
                });

                await fetchTableFormats();

            } catch (error) {
                console.error('Error fetching table names:', error);
            }
        };

        const fetchTableFormats = async () => {
            try {
                await connectToDatabase();
                const selectFormatElement = document.getElementById('data-format-select');
                selectFormatElement.innerHTML = '';

                const selectElement = document.getElementById('data-select');
                const selectedData = selectElement.value;

                const dataFormatIndexs = await queryDatabase(`SELECT * FROM [${selectedData}_format];`);
                dataFormatIndexs.forEach(format => {
                    const option = document.createElement('option');
                    option.value = format.data_format_index;
                    option.textContent = format.comment;
                    selectFormatElement.appendChild(option);
                });
                await getTableData();
            } catch (error) {
                console.error('Error fetching table names:', error);
            }
        };

        window.onload = fetchTableNames;
        const getTableData = async () => {
            try {
                await connectToDatabase();
                const selectedData = document.getElementById('data-select').value;
                const selectedFormatData = document.getElementById('data-format-select');
                // Check which period is selected
                const period = document.querySelector('input[name="period"]:checked').value;
                let queryWhere;

                const today = new Date();
                
                // Calculate the timestamp based on the selected period
                let formattedTimestamp;

                if (period === 'OneDay') {
                    const yesterday = new Date();
                    yesterday.setDate(yesterday.getDate() - 1);
                    formattedTimestamp = Math.floor(yesterday.getTime() / 1000);
                    queryWhere = ` WHERE [${selectedData}].time@timestamp >= ${formattedTimestamp};`;
                } else if (period === 'OneWeek') {
                    const lastWeek = new Date();
                    lastWeek.setDate(lastWeek.getDate() - 7);
                    formattedTimestamp = Math.floor(lastWeek.getTime() / 1000);
                    queryWhere = ` WHERE [${selectedData}].time@timestamp >= ${formattedTimestamp};`;
                } else if (period === 'OneMonth') {
                    const lastMonth = new Date();
                    lastMonth.setMonth(lastMonth.getMonth() - 1);
                    formattedTimestamp = Math.floor(lastMonth.getTime() / 1000);
                    queryWhere = ` WHERE [${selectedData}].time@timestamp >= ${formattedTimestamp};`;
                } else if (period === 'HalfYear') {
                    const lastHalfYear = new Date();
                    lastHalfYear.setMonth(lastHalfYear.getMonth() - 6);
                    formattedTimestamp = Math.floor(lastHalfYear.getTime() / 1000);
                    queryWhere = ` WHERE [${selectedData}].time@timestamp >= ${formattedTimestamp};`;
                }
                else if (period === 'OneYear') {
                    const lastYear = new Date();
                    lastYear.setFullYear(lastYear.getFullYear() - 1);
                    formattedTimestamp = Math.floor(lastYear.getTime() / 1000);
                    queryWhere = ` WHERE [${selectedData}].time@timestamp >= ${formattedTimestamp};`;
                }
                else if (period === 'Custom') {
                    const periodFrom = document.getElementById('PeriodFrom').value;
                    const periodTo = document.getElementById('PeriodTo').value;

                    // Create Date objects from the string inputs
                    const dateFrom = new Date(periodFrom);
                    const dateTo = new Date(periodTo);

                    // Check if the dates are valid
                    if (isNaN(dateFrom.getTime()) || isNaN(dateTo.getTime())) {
                        outputDiv.innerHTML = 'Invalid date range. Please enter valid dates.';
                        return;
                    }

                    let formattedTimestampFrom = Math.floor(dateFrom.getTime() / 1000);
                    let formattedTimestampTo = Math.floor(dateTo.getTime() / 1000);

                    queryWhere = ` WHERE [${selectedData}].time@timestamp >= ${formattedTimestampFrom} AND [${selectedData}].time@timestamp <= ${formattedTimestampTo};`;
                }
                // let query = `SELECT * FROM [${selectedData}] ` + queryWhere;
                let query = `SELECT [${selectedData}].data_index, 
                      [${selectedData}].time@timestamp, 
                      [${selectedData}].data_format_${selectedFormatData.value} as data_format_${selectedFormatData.value}
                    FROM [${selectedData}] ` + queryWhere;
                const result = await queryDatabase(query);
                // // Assume you have a mapping of comments
                // const commentsMapping = await queryDatabase(`SELECT * from [${selectedData}_format]`);
                // // Transform the data
                // const transformedData = result.map(item => {
                //     const transformedItem = {
                //         data_index: item.data_index,
                //         "time@timestamp": item["time@timestamp"]
                //     };

                //     // Dynamically add data_format fields based on available keys
                //     for (let i = 0; i < commentsMapping.length; i++) {
                //         const dataFormatKey = `data_format_${i}`;
                //         if (item[dataFormatKey] !== undefined) {
                //             transformedItem[commentsMapping[i].comment] = item[dataFormatKey];
                //         }
                //     }

                //     return transformedItem;
                // });

                const createTable = (data) => {
                    const defaultEntriesPerPage = 10
                    let currentPage = 1;
                    let entriesPerPage = defaultEntriesPerPage;
                    let totalPages = Math.ceil(data.length / entriesPerPage);

                    const wrapper = document.createElement('div');
                    wrapper.style.width = '100%';

                    // Top control panel (entries per page select)
                    const topControlPanel = document.createElement('div');
                    topControlPanel.style.display = 'flex';
                    topControlPanel.style.justifyContent = 'flex-start';
                    topControlPanel.style.marginBottom = '10px';

                    const entriesSelectLabel = document.createElement('label');
                    entriesSelectLabel.textContent = 'Entries per page: ';
                    entriesSelectLabel.style.marginRight = '5px';

                    const entriesSelect = document.createElement('select');
                    [5, 10, 20, 50].forEach(size => {
                        const option = document.createElement('option');
                        option.value = size;
                        option.textContent = `${size}`;
                        if (size === entriesPerPage) option.selected = true;
                        entriesSelect.appendChild(option);
                    });

                    entriesSelect.onchange = (event) => {
                        entriesPerPage = parseInt(event.target.value);
                        totalPages = Math.ceil(data.length / entriesPerPage);
                        currentPage = 1; // Reset to the first page
                        updateTable();
                    };

                    topControlPanel.appendChild(entriesSelectLabel);
                    topControlPanel.appendChild(entriesSelect);
                    wrapper.appendChild(topControlPanel);

                    const tableContainer = document.createElement('div');
                    tableContainer.style.overflowX = 'auto';
                    tableContainer.style.width = '100%';
                    wrapper.appendChild(tableContainer);

                    const table = document.createElement('table');
                    table.style.width = '100%';
                    table.style.borderCollapse = 'collapse';
                    tableContainer.appendChild(table);

                    const renderTable = () => {
                        table.innerHTML = '';

                        const header = table.createTHead();
                        const headerRow = header.insertRow(0);
                        Object.keys(data[0]).forEach(key => {
                            const cell = headerRow.insertCell();
                            cell.innerHTML = `<strong>${key}</strong>`;
                            cell.style.position = 'sticky';
                            cell.style.top = '0';
                            cell.style.backgroundColor = '#fff';
                            cell.style.zIndex = '10';
                        });

                        const tbody = table.createTBody();
                        const start = (currentPage - 1) * entriesPerPage;
                        const end = Math.min(start + entriesPerPage, data.length);
                        const currentData = data.slice(start, end);

                        currentData.forEach(item => {
                            const row = tbody.insertRow();

                            Object.entries(item).forEach(([key, value], index) => {
                                const cell = row.insertCell();

                                if (typeof value === 'number' && value > 0 && value < 2147483647 && index === 1) {
                                    const date = new Date(value * 1000);
                                    const formattedDateTime = date.toLocaleString();
                                    cell.textContent = formattedDateTime;
                                } else {
                                    cell.textContent = value;
                                }
                            });
                        });
                    };

                    const renderPagination = () => {
                        const existingPagination = wrapper.querySelector('.pagination-line');
                        if (existingPagination) {
                            existingPagination.remove();
                        }

                        const paginationLine = document.createElement('div');
                        paginationLine.className = 'pagination-line';
                        paginationLine.style.display="flex";
                        paginationLine.style.justifyContent="space-between";
                        paginationLine.style.marginTop="10px";

                        const pageInfo = document.createElement('span');
                        pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
                        pageInfo.style.display = 'flex';
                        pageInfo.style.lineHeight = '4';
                        
                        const pagination = document.createElement('div');
                        pagination.className = 'pagination';
                        pagination.style.display = 'flex';

                        const prevButton = document.createElement('button');
                        prevButton.textContent = 'Previous';
                        prevButton.disabled = currentPage === 1;
                        prevButton.onclick = () => {
                            if (currentPage > 1) {
                                currentPage--;
                                updateTable();
                            }
                        };

                        const nextButton = document.createElement('button');
                        nextButton.textContent = 'Next';
                        nextButton.disabled = currentPage === totalPages;
                        nextButton.onclick = () => {
                            if (currentPage < totalPages) {
                                currentPage++;
                                updateTable();
                            }
                        };

                        pagination.appendChild(prevButton);
                        pagination.appendChild(nextButton);
                        
                        paginationLine.appendChild(pageInfo);
                        paginationLine.appendChild(pagination);

                        wrapper.appendChild(paginationLine);
                    };

                    const updateTable = () => {
                        renderTable();
                        renderPagination();
                    };

                    updateTable();

                    return wrapper;
                };

                const createGraph = (data) => {
                    const wrapper = document.createElement('div');
                    wrapper.style.overflowX = 'auto'; // Enable horizontal scrolling
                    wrapper.style.width = '100%'; // Set width to 100%

                    const labels = [];
                    const dataPoints = [];
                    const now = new Date();

                    if (period === "OneDay") {
                        // Get the start of the day (midnight)
                        const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 4, 0, 0, 0, 0);

                        // Generate labels for each hour of the day
                        for (let i = 0; i < 24; i++) {
                            const hourTime = new Date(startOfDay.getTime() + i * 60 * 60 * 1000);
                            const hours = hourTime.getHours();
                            const periodLabel = hours < 12 ? 'AM' : 'PM';
                            const formattedTime = `${(hours % 12) || 12} ${periodLabel}`;
                            const label = `${hourTime.getMonth() + 1}/${hourTime.getDate()} ${formattedTime}`;
                            labels.push(label);
                        }

                        // Generate data points based on the hour intervals
                        data.forEach(item => {
                            const time = new Date(item['time@timestamp'] * 1000);
                            const timeDifference = time.getTime() - startOfDay.getTime();
                            const exactPosition = timeDifference / (60 * 60 * 1000); // Convert time difference to hours
                            const value = parseFloat(item[Object.keys(item)[2]]);
                            dataPoints.push({ x: exactPosition, y: value });
                        });
                    } else if (period === "OneWeek") {
                        // Get the start of the week (Sunday)
                        const startOfWeek = new Date(now.getFullYear(), now.getMonth(), now.getDate() - now.getDay(), 0, 0, 0, 0);

                        // Generate labels for each 6-hour interval over the week
                        for (let i = 0; i < 28; i++) {
                            const intervalTime = new Date(startOfWeek.getTime() + i * 6 * 60 * 60 * 1000);
                            const hours = intervalTime.getHours();
                            const periodLabel = hours < 12 ? 'AM' : 'PM';
                            const formattedTime = `${(hours % 12) || 12} ${periodLabel}`;
                            const label = `${intervalTime.getMonth() + 1}/${intervalTime.getDate()} ${formattedTime}`;
                            labels.push(label);
                        }

                        // Generate data points based on the 6-hour intervals
                        data.forEach(item => {
                            const time = new Date(item['time@timestamp'] * 1000);
                            const timeDifference = time.getTime() - startOfWeek.getTime();
                            const exactPosition = timeDifference / (6 * 60 * 60 * 1000); // Convert time difference to 6-hour intervals
                            const value = parseFloat(item[Object.keys(item)[2]]);
                            dataPoints.push({ x: exactPosition, y: value });
                        });
                    }

                    // Create the canvas element for the chart
                    const canvas = document.createElement('canvas');
                    wrapper.appendChild(canvas);
console.log(labels);
console.log(dataPoints);
                    const ctx = canvas.getContext('2d');
                    new Chart(ctx, {
                        type: 'line',
                        data: {
                            datasets: [{
                                label: 'Data Values',
                                data: dataPoints,
                                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                borderColor: 'rgba(75, 192, 192, 1)',
                                borderWidth: 1,
                                spanGaps: true,
                                fill: false,
                            }]
                        },
                        options: {
                            scales: {
                                x: {
                                    type: 'linear',
                                    position: 'bottom',
                                    title: {
                                        display: true,
                                        text: period === "OneDay" ? 'Hour of the Day' : 'Day and Time'
                                    },
                                    ticks: {
                                        autoSkip: false,
                                        maxTicksLimit: period === "OneDay" ? 24 : 28,
                                        callback: function(value) {
                                            return labels[Math.floor(value)] || '';
                                        }
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: 'Value'
                                    },
                                    beginAtZero: true
                                }
                            },
                            plugins: {
                                tooltip: {
                                    callbacks: {
                                        label: function(tooltipItem) {
                                            const index = Math.floor(tooltipItem.raw.x);
                                            return `Value: ${tooltipItem.raw.y} at ${labels[index] || 'N/A'}`;
                                        }
                                    }
                                }
                            }
                        }
                    });

                    return wrapper;
                };

                if (!result || result.length === 0) {
                    outputDiv.innerHTML = 'No data found.';
                } else {
                    console.log(result);
                    const table = createTable(result);
                    const graph = createGraph(result);
                    outputDiv.innerHTML = '';
                    outputDiv.appendChild(table);
                    outputDiv.appendChild(graph);
                    outputDiv.dataset.result = JSON.stringify(result); // Store result for export
                }
            } catch (error) {
                console.error('Error occurred:', error);
                outputDiv.innerHTML = 'Error: ' + error.message;
            }
        };

        const exportToCSV = (data) => {
            const csvRows = [];
            const headers = Object.keys(data[0]);
            csvRows.push(headers.join(','));
            for (const row of data) {
                const values = headers.map(header => {
                    const escaped = ('' + row[header]).replace(/"/g, '\\"');
                    return `"${escaped}"`;
                });
                csvRows.push(values.join(','));
            }

            const blob = new Blob([csvRows.join('\n')], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.setAttribute('href', url);
            a.setAttribute('download', 'data.csv');
            a.click();
        };

        const exportToPDF = (data) => {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            const headers = Object.keys(data[0]);
            const rows = data.map(item => headers.map(header => item[header]));

            doc.autoTable({
                head: [headers],
                body: rows,
            });

            doc.save('data.pdf');
        };

        document.getElementById('export-pdf').addEventListener('click', () => {
            let data = JSON.parse(outputDiv.dataset.result);

            // Convert the "time@timestamp" values to a readable date format
            data = data.map(row => {
                if (row['time@timestamp']) {
                    const date = new Date(row['time@timestamp'] * 1000); // Convert to milliseconds
                    row['time@timestamp'] = date.toLocaleString('en-US'); // Format to MM/DD/YYYY, HH:MM:SS AM/PM
                }
                return row;
            });

            exportToPDF(data);
        });

        document.getElementById('export-csv').addEventListener('click', () => {
            let data = JSON.parse(outputDiv.dataset.result);

            // Convert the "time@timestamp" values to a readable date format
            data = data.map(row => {
                if (row['time@timestamp']) {
                    const date = new Date(row['time@timestamp'] * 1000); // Convert to milliseconds
                    row['time@timestamp'] = date.toLocaleString('en-US'); // Format to MM/DD/YYYY, HH:MM:SS AM/PM
                }
                return row;
            });
console.log(data);
            exportToCSV(data);
        });


        // document.getElementById('btn__get-graph').addEventListener('click', function() {
        //     const periodFrom = document.getElementById('PeriodFrom').value;
        //     const periodTo = document.getElementById('PeriodTo').value;
        //     const selectedPeriod = document.querySelector('input[name="period"]:checked').value;

        //     // Display the selected values in the output div
        //     const outputDiv = document.getElementById('output');
        //     outputDiv.innerHTML = `
        //         <h2>Selected Period</h2>
        //         <p>From: ${periodFrom}</p>
        //         <p>To: ${periodTo}</p>
        //         <p>Period Type: ${selectedPeriod}</p>
        //     `;
        // });

        // Get all radio buttons and the period-from-to section
        const radioButtons = document.querySelectorAll('input[name="period"]');
        const periodFromTo = document.getElementById('period-from-to');

        // Add event listener to each radio button
        radioButtons.forEach(radio => {
            radio.addEventListener('change', async function() {
                // Show the period-from-to section if Custom is selected, otherwise hide it
                if (this.value === 'Custom') {
                    periodFromTo.style.display = 'table-row'; // Show the row
                } else {
                    periodFromTo.style.display = 'none'; // Hide the row
                }

                await getTableData();
            });
        });

    </script>
</body>
</html>
