<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Richmond System</title>
    <style>
        .noborder { border: none; }
        .input--medium { width: 200px; }
        #period-from-to { display: none; } /* Initially hide the period-from-to section */
        #period_table { margin-top: 15px; margin-bottom: 15px;}
    </style>
    <style>
        table {
            border: 1px solid #ccc;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
            height: 24px;
        }

        th {
            background-color: #f2f2f2;
        }
    </style>
    <style>
        /* Style for the select element */
        #data-select {
            padding: 10px; /* Add padding */
            font-size: 16px; /* Increase font size */
            width: 120px; /* Set width */
        }

        #data-format-select {
            padding: 10px; /* Add padding */
            font-size: 16px; /* Increase font size */
            width: 250px; /* Set width */
        }
    
        /* Style for buttons */
        button {
            padding: 10px 20px; /* Add padding */
            font-size: 16px; /* Increase font size */
            margin: 10px 10px; /* Space between buttons */
            cursor: pointer; /* Change cursor on hover */
        }
        /* Add this CSS to your stylesheet */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .spinner {
            border: 16px solid #f3f3f3;
            border-radius: 50%;
            border-top: 16px solid #3498db;
            width: 120px;
            height: 120px;
            -webkit-animation: spin 2s linear infinite;
            animation: spin 2s linear infinite;
        }

        #logo-icon {
            width: 40px;
            float: right;
        }

        .site-title {
            float: left;
        }
        @-webkit-keyframes spin {
            0% { -webkit-transform: rotate(0deg); }
            100% { -webkit-transform: rotate(360deg); }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

    </style>
    <style>
        body { font-family: Arial, sans-serif; }
        #output { white-space: pre-wrap; background: #f4f4f4; padding: 10px; border: 1px solid #ccc; }
        /* table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; } */
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <script src="assets/js/Chart.js-master/chart.js"></script>
</head>
<body>
    <!-- Add this HTML to your page -->
    <div id="loading-screen" style="display: flex;">
        <div class="spinner"></div>
        <p>Loading...</p>
    </div>
    <div style="align-content: baseline;">
        <h1 class="site-title">Richmond System</h1>
        <img src="assets/icon/logo.png" id="logo-icon" alt="logo">
    </div>
    
    
    <label for="data-select">Select Data Source:</label>
    <select id="data-select" onchange="fetchTableFormats()"></select>
    <select id="data-format-select" onchange="getTableData()"></select>

    <button id="export-pdf">Export to PDF</button>
    <button id="export-csv">Export to CSV</button>

    <table id="period_table">
        <tr id="graph-period" class="noborder">
            <th class="cell--default">Period</th>
            <td>
                <div class="input__radio-2__wrap">
                    <input type="radio" checked="checked" class="input__radio-2" id="period-day" value="OneDay" name="period">
                    <label for="period-day">1 Day</label>
                    
                    <input type="radio" class="input__radio-2" id="period-week" value="OneWeek" name="period">
                    <label for="period-week">1 Week</label>

                    <input type="radio" class="input__radio-2" id="period-custom" value="Custom" name="period">
                    <label for="period-custom">Custom</label>
                    <!-- <input type="radio" class="input__radio-2" id="period-month" value="OneMonth" name="period">
                    <label for="period-month">1 Month</label>
                    
                    <input type="radio" class="input__radio-2" id="period-half-year" value="HalfYear" name="period">
                    <label for="period-half-year">6 Months</label>
                    
                    <input type="radio" class="input__radio-2" id="period-year" value="OneYear" name="period">
                    <label for="period-year">1 Year</label>
                    -->
                </div>
            </td>
            <td></td>
        </tr>
    
        <tr id="period-from-to">
            <th></th>
            <td>
                <input value="2024-08-18T00:00" class="input input--text input--medium" id="PeriodFrom" name="PeriodFrom" type="datetime-local">
                <span class="field-validation-valid" data-valmsg-for="PeriodFrom"></span>
                -
                <input value="2024-08-19T10:00" class="input input--text input--medium" id="PeriodTo" name="PeriodTo" type="datetime-local">
                <span class="field-validation-valid" data-valmsg-for="PeriodTo"></span>
                <button class="btn btn--low column__box--solo" type="button" id="btn__get-graph">Confirm</button>
            </td>
            <td></td>
        </tr>
    </table>    
    <div id="output_graph"></div>
    <div id="output"></div>
    <div id="chart-container"></div>
    <script>
      
            document.getElementById('loading-screen').style.display = 'flex';
            const { connectToDatabase, queryDatabase } = require('./db');
            // Declare outputDiv at the top
            const outputDiv = document.getElementById('output');
            const outputGraphDiv = document.getElementById('output_graph');
            const fetchTableNames = async () => {
                try {
                    await connectToDatabase();
                    const tables = await queryDatabase("SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';");
                    const selectElement = document.getElementById('data-select');
                    const filteredTables = tables.filter(table => table.TABLE_NAME.endsWith('_data'));

                    // Populate the select element with filtered table names
                    filteredTables.forEach(table => {
                        const option = document.createElement('option');
                        option.value = table.TABLE_NAME;
                        option.textContent = table.TABLE_NAME;
                        selectElement.appendChild(option);
                    });

                    selectElement.innerHTML = '';
                    filteredTables.forEach(table => {
                        const tableName = table.TABLE_NAME.replace(/^cMT-4429_/, '').replace(/_data$/, '');
                        // const tableName = table.TABLE_NAME.replace(/^hostname_/, '').replace(/_data$/, '');
                        const option = document.createElement('option');
                        option.value = table.TABLE_NAME;
                        option.textContent = tableName;
                        selectElement.appendChild(option);
                    });

                    await fetchTableFormats();

                } catch (error) {
                    console.error('Error fetching table names:', error);
                }
            };

            const fetchTableFormats = async () => {
                try {
                    await connectToDatabase();
                    const selectFormatElement = document.getElementById('data-format-select');
                    selectFormatElement.innerHTML = '';

                    const selectElement = document.getElementById('data-select');
                    const selectedData = selectElement.value;

                    const dataFormatIndexs = await queryDatabase(`SELECT * FROM [${selectedData}_format];`);
                    dataFormatIndexs.forEach(format => {
                        const option = document.createElement('option');
                        option.value = format.data_format_index;
                        option.textContent = format.comment;
                        selectFormatElement.appendChild(option);
                    });
                    await getTableData();
                } catch (error) {
                    console.error('Error fetching table names:', error);
                }
            };

            window.onload = fetchTableNames;
            
            const getTableData = async () => {
                try {
                    await connectToDatabase();
                    const selectedData = document.getElementById('data-select').value;
                    const selectedFormatData = document.getElementById('data-format-select');
                    // Check which period is selected
                    const period = document.querySelector('input[name="period"]:checked').value;
                    let queryWhere;

                    const today = new Date();
                    
                    // Calculate the timestamp based on the selected period
                    let formattedTimestamp;

                    // if (period === 'OneDay') {
                    //     const yesterday = new Date();
                    //     yesterday.setDate(yesterday.getDate() - 1);
                    //     formattedTimestamp = Math.floor(yesterday.getTime() / 1000);
                    //     queryWhere = ` WHERE [${selectedData}].time@timestamp >= ${formattedTimestamp};`;
                    // } else if (period === 'OneWeek') {
                    //     const lastWeek = new Date();
                    //     lastWeek.setDate(lastWeek.getDate() - 7);
                    //     formattedTimestamp = Math.floor(lastWeek.getTime() / 1000);
                    //     queryWhere = ` WHERE [${selectedData}].time@timestamp >= ${formattedTimestamp};`;
                    // }

                    if (period === 'OneDay') {
                        const now = new Date();
                        const currentTimestamp = Math.floor(now.getTime() / 1000); // Current timestamp in seconds

                        let twentyFourHoursAgo = new Date();
                        twentyFourHoursAgo.setDate(twentyFourHoursAgo.getDate() - 1); // 24 hours ago
                        formattedTimestamp = Math.floor(twentyFourHoursAgo.getTime() / 1000); // Timestamp for 24 hours ago

                        // Update the query to include the range from 24 hours ago to now
                        queryWhere = ` WHERE [${selectedData}].time@timestamp >= ${formattedTimestamp} AND [${selectedData}].time@timestamp <= ${currentTimestamp};`;

                    } else if (period === 'OneWeek') {
                        const now = new Date(); // Current time
                        let startOfPeriod = new Date();
                        startOfPeriod.setDate(startOfPeriod.getDate() - 7); // 7 days ago

                        // Convert to Unix timestamps (seconds since epoch)
                        let startTimestamp = Math.floor(startOfPeriod.getTime() / 1000);
                        let endTimestamp = Math.floor(now.getTime() / 1000); // Current time

                        // Update the query to include the range
                        queryWhere = ` WHERE [${selectedData}].time@timestamp >= ${startTimestamp} AND [${selectedData}].time@timestamp <= ${endTimestamp};`;

                    } else if (period === 'OneMonth') {
                        const lastMonth = new Date();
                        lastMonth.setMonth(lastMonth.getMonth() - 1);
                        formattedTimestamp = Math.floor(lastMonth.getTime() / 1000);
                        queryWhere = ` WHERE [${selectedData}].time@timestamp >= ${formattedTimestamp};`;
                    } else if (period === 'HalfYear') {
                        const lastHalfYear = new Date();
                        lastHalfYear.setMonth(lastHalfYear.getMonth() - 6);
                        formattedTimestamp = Math.floor(lastHalfYear.getTime() / 1000);
                        queryWhere = ` WHERE [${selectedData}].time@timestamp >= ${formattedTimestamp};`;
                    }
                    else if (period === 'OneYear') {
                        const lastYear = new Date();
                        lastYear.setFullYear(lastYear.getFullYear() - 1);
                        formattedTimestamp = Math.floor(lastYear.getTime() / 1000);
                        queryWhere = ` WHERE [${selectedData}].time@timestamp >= ${formattedTimestamp};`;
                    }
                    else if (period === 'Custom') {
                        const periodFrom = document.getElementById('PeriodFrom').value;
                        const periodTo = document.getElementById('PeriodTo').value;

                        // Create Date objects from the string inputs
                        const dateFrom = new Date(periodFrom);
                        const dateTo = new Date(periodTo);

                        // Check if the dates are valid
                        if (isNaN(dateFrom.getTime()) || isNaN(dateTo.getTime())) {
                            outputDiv.innerHTML = 'Invalid date range. Please enter valid dates.';
                            return;
                        }

                        let formattedTimestampFrom = Math.floor(dateFrom.getTime() / 1000);
                        let formattedTimestampTo = Math.floor(dateTo.getTime() / 1000);

                        queryWhere = ` WHERE [${selectedData}].time@timestamp >= ${formattedTimestampFrom} AND [${selectedData}].time@timestamp <= ${formattedTimestampTo};`;
                    }
                    // let query = `SELECT * FROM [${selectedData}] ` + queryWhere;
                    let query = `SELECT [${selectedData}].data_index as "Index", 
                        [${selectedData}].time@timestamp as "Timestamp", 
                        [${selectedData}].data_format_${selectedFormatData.value} as "Value"
                        FROM [${selectedData}] ` + queryWhere;
                    const result = await queryDatabase(query);

                    // // Assume you have a mapping of comments
                    // const commentsMapping = await queryDatabase(`SELECT * from [${selectedData}_format]`);
                    // // Transform the data
                    // const transformedData = result.map(item => {
                    //     const transformedItem = {
                    //         data_index: item.data_index,
                    //         "time@timestamp": item["time@timestamp"]
                    //     };

                    //     // Dynamically add data_format fields based on available keys
                    //     for (let i = 0; i < commentsMapping.length; i++) {
                    //         const dataFormatKey = `data_format_${i}`;
                    //         if (item[dataFormatKey] !== undefined) {
                    //             transformedItem[commentsMapping[i].comment] = item[dataFormatKey];
                    //         }
                    //     }

                    //     return transformedItem;
                    // });

                    const createTable = (data) => {
                        const defaultEntriesPerPage = 10
                        let currentPage = 1;
                        let entriesPerPage = defaultEntriesPerPage;
                        let totalPages = Math.ceil(data.length / entriesPerPage);

                        const wrapper = document.createElement('div');
                        wrapper.style.width = '100%';

                        // Top control panel (entries per page select)
                        const topControlPanel = document.createElement('div');
                        topControlPanel.style.display = 'flex';
                        topControlPanel.style.justifyContent = 'flex-start';
                        topControlPanel.style.marginBottom = '30px';

                        const entriesSelectLabel = document.createElement('label');
                        entriesSelectLabel.textContent = 'Entries per page: ';
                        entriesSelectLabel.style.marginRight = '5px';

                        const entriesSelect = document.createElement('select');
                        [5, 10, 20, 50].forEach(size => {
                            const option = document.createElement('option');
                            option.value = size;
                            option.textContent = `${size}`;
                            if (size === entriesPerPage) option.selected = true;
                            entriesSelect.appendChild(option);
                        });

                        entriesSelect.onchange = (event) => {
                            entriesPerPage = parseInt(event.target.value);
                            totalPages = Math.ceil(data.length / entriesPerPage);
                            currentPage = 1; // Reset to the first page
                            updateTable();
                        };

                        topControlPanel.appendChild(entriesSelectLabel);
                        topControlPanel.appendChild(entriesSelect);
                        wrapper.appendChild(topControlPanel);

                        const tableContainer = document.createElement('div');
                        tableContainer.style.overflowX = 'auto';
                        tableContainer.style.width = '100%';
                        wrapper.appendChild(tableContainer);

                        const table = document.createElement('table');
                        table.style.width = '100%';
                        table.style.borderCollapse = 'collapse';
                        tableContainer.appendChild(table);

                        const renderTable = () => {
                            table.innerHTML = '';

                            const header = table.createTHead();
                            const headerRow = header.insertRow(0);
                            Object.keys(data[0]).forEach((key, index) => {
                                const cell = headerRow.insertCell();
                                cell.innerHTML = `<strong>${key}</strong>`;
                                cell.style.position = 'sticky';
                                cell.style.top = '0';
                                cell.style.backgroundColor = '#fff';
                                cell.style.zIndex = '10';
                            });

                            const tbody = table.createTBody();
                            const start = (currentPage - 1) * entriesPerPage;
                            const end = Math.min(start + entriesPerPage, data.length);
                            const currentData = data.slice(start, end);
                            currentData.forEach(item => {
                                const row = tbody.insertRow();

                                Object.entries(item).forEach(([key, value], index) => {
                                    const cell = row.insertCell();
                                    if (typeof value === 'number' && value > 0 && value < 2147483647 && index === 1) {
                                        const date = new Date(value * 1000);
                                        const formattedDateTime = date.toLocaleString();
                                        cell.textContent = formattedDateTime;
                                    } else {
                                        cell.textContent = value;
                                    }
                                });
                            });
                        };

                        const renderPagination = () => {
                            const existingPagination = wrapper.querySelector('.pagination-line');
                            if (existingPagination) {
                                existingPagination.remove();
                            }

                            const paginationLine = document.createElement('div');
                            paginationLine.className = 'pagination-line';
                            paginationLine.style.display="flex";
                            paginationLine.style.justifyContent="space-between";
                            paginationLine.style.marginTop="10px";

                            const pageInfo = document.createElement('span');
                            pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
                            pageInfo.style.display = 'flex';
                            pageInfo.style.lineHeight = '4';
                            
                            const pagination = document.createElement('div');
                            pagination.className = 'pagination';
                            pagination.style.display = 'flex';

                            const prevButton = document.createElement('button');
                            prevButton.textContent = 'Previous';
                            prevButton.disabled = currentPage === 1;
                            prevButton.onclick = () => {
                                if (currentPage > 1) {
                                    currentPage--;
                                    updateTable();
                                }
                            };

                            const nextButton = document.createElement('button');
                            nextButton.textContent = 'Next';
                            nextButton.disabled = currentPage === totalPages;
                            nextButton.onclick = () => {
                                if (currentPage < totalPages) {
                                    currentPage++;
                                    updateTable();
                                }
                            };

                            pagination.appendChild(prevButton);
                            pagination.appendChild(nextButton);
                            
                            paginationLine.appendChild(pageInfo);
                            paginationLine.appendChild(pagination);

                            wrapper.appendChild(paginationLine);
                        };

                        const updateTable = () => {
                            renderTable();
                            renderPagination();
                        };

                        updateTable();

                        return wrapper;
                    };

                    const createGraph = (data) => {
                        const wrapper = document.createElement('div');
                        // wrapper.style.overflowX = 'auto'; // Enable horizontal scrolling
                        wrapper.style.width = '100%'; // Set width to 100%
                        wrapper.style.height = "600px";
                        wrapper.style.marginBottom = "30px";
                        wrapper.id = 'statistic-graph'; // Set class name

                        const labels = [];
                        const dataPoints = [];
                        const now = new Date();
                        const tempDataPoints = [];
                        
                        const selectElement = document.getElementById('data-select');
                        const selectedOption = selectElement.options[selectElement.selectedIndex];
                        const selectedText = selectedOption.text;
                        if (period === "OneDay") {
                            const now = new Date();

                            // Calculate the starting point, which is 24 hours ago from the current time
                            const startOfDay = new Date(now.getTime() - 24 * 60 * 60 * 1000);

                            // Generate labels for each hour from 24 hours ago to now
                            for (let i = 0; i < 24; i++) {
                                const hourTime = new Date(startOfDay.getTime() + i * 60 * 60 * 1000);
                                const hours = hourTime.getHours();
                                const periodLabel = hours < 12 ? 'AM' : 'PM';
                                const formattedTime = `${(hours % 12) || 12} ${periodLabel}`;
                                const label = `${hourTime.getMonth() + 1}/${hourTime.getDate()} ${formattedTime}`;
                                labels.push(label);
                            }

                            // Generate data points based on the hour intervals
                            data.forEach(item => {
                                const time = new Date(item['Timestamp'] * 1000);
                                const timeDifference = time.getTime() - startOfDay.getTime();
                                const exactPosition = timeDifference / (60 * 60 * 1000); // Convert time difference to hours
                                const value = parseFloat(item[Object.keys(item)[2]]);
                                dataPoints.push({ x: exactPosition, y: value });
                                tempDataPoints.push({ x: exactPosition, t: time.toLocaleString('en-US') });
                            });

                        } else if (period === "OneWeek") {
                            const now = new Date();

                            // Calculate the starting point, which is 7 days ago from the current time
                            const startOfPeriod = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 7, now.getHours(), 0, 0, 0);

                            // Calculate the number of 6-hour intervals between startOfPeriod and now
                            const intervalCount = Math.ceil((now.getTime() - startOfPeriod.getTime()) / (6 * 60 * 60 * 1000));

                            // Generate labels for each 6-hour interval from 7 days ago to now
                            for (let i = 0; i < intervalCount; i++) {
                                const intervalTime = new Date(startOfPeriod.getTime() + i * 6 * 60 * 60 * 1000);
                                const hours = intervalTime.getHours();
                                const periodLabel = hours < 12 ? 'AM' : 'PM';
                                const formattedTime = `${(hours % 12) || 12} ${periodLabel}`;
                                const label = `${intervalTime.getMonth() + 1}/${intervalTime.getDate()} ${formattedTime}`;
                                labels.push(label);
                            }

                            // Generate data points based on the 6-hour intervals
                            data.forEach(item => {
                                const time = new Date(item['Timestamp'] * 1000);
                                const timeDifference = time.getTime() - startOfPeriod.getTime();
                                const exactPosition = timeDifference / (6 * 60 * 60 * 1000); // Convert time difference to 6-hour intervals
                                const value = parseFloat(item[Object.keys(item)[2]]);
                                dataPoints.push({ x: exactPosition, y: value });
                                tempDataPoints.push({ x: exactPosition, t: time.toLocaleString('en-US') });
                            });
                        } else if (period === "Custom") {
                            const periodFrom = document.getElementById('PeriodFrom').value;
                            const periodTo = document.getElementById('PeriodTo').value;
                            // Create Date objects from the string inputs
                            const dateFrom = new Date(periodFrom);
                            const dateTo = new Date(periodTo);

                            // Calculate the starting point and end point
                            const startOfPeriod = new Date(dateFrom.getFullYear(), dateFrom.getMonth(), dateFrom.getDate(), dateFrom.getHours(), 0, 0, 0);
                            const endOfPeriod = new Date(dateTo.getFullYear(), dateTo.getMonth(), dateTo.getDate(), dateTo.getHours(), 0, 0, 0);

                            // Calculate the number of 6-hour intervals between startOfPeriod and now
                            const intervalCount = Math.ceil((endOfPeriod.getTime() - startOfPeriod.getTime()) / (6 * 60 * 60 * 1000));

                            // Generate labels for each 6-hour interval from 7 days ago to now
                            for (let i = 0; i < intervalCount; i++) {
                                const intervalTime = new Date(startOfPeriod.getTime() + i * 6 * 60 * 60 * 1000);
                                const hours = intervalTime.getHours();
                                const periodLabel = hours < 12 ? 'AM' : 'PM';
                                const formattedTime = `${(hours % 12) || 12} ${periodLabel}`;
                                const label = `${intervalTime.getMonth() + 1}/${intervalTime.getDate()} ${formattedTime}`;
                                labels.push(label);
                            }

                            // Generate data points based on the 6-hour intervals
                            data.forEach(item => {
                                const time = new Date(item['Timestamp'] * 1000);
                                const timeDifference = time.getTime() - startOfPeriod.getTime();
                                const exactPosition = timeDifference / (6 * 60 * 60 * 1000); // Convert time difference to 6-hour intervals
                                const value = parseFloat(item[Object.keys(item)[2]]);
                                dataPoints.push({ x: exactPosition, y: value });
                                tempDataPoints.push({ x: exactPosition, t: time.toLocaleString('en-US') });
                            });
                        }

                        // Create the canvas element for the chart
                        const canvas = document.createElement('canvas');
                        wrapper.appendChild(canvas);
                        // Sorting dataPoints data
                        const sortedDataPoints = dataPoints.sort((a, b) => {
                            if (a.x === b.x) {
                                return a.y - b.y; // If x values are the same, sort by y value
                            } else {
                                return a.x - b.x; // Otherwise, sort by x value
                            }
                        });
                        const ctx = canvas.getContext('2d');

                        console.log(period + "---" + labels);
                        console.log(period + "---" + sortedDataPoints[0].x);
                        const myChart = new Chart(ctx, {
                            type: 'line',
                            data: {
                                datasets: [{
                                    label: 'Data Values',
                                    data: sortedDataPoints,
                                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                    borderColor: 'rgba(75, 192, 192, 1)',
                                    borderWidth: 1,
                                    spanGaps: true,
                                    fill: false,
                                    pointRadius: 5,            // Hide the data point markers
                                    pointHoverRadius: 15,        // Show a marker when hovering
                                }]
                            },
                            options: {
                                scales: {
                                    x: {
                                        type: 'linear',  // Set the x-axis to be a linear scale
                                        position: 'bottom',
                                        title: {
                                            display: true,
                                            text: 'Time (custom x-value)'
                                        },
                                        ticks: {
                                            callback: function(value, index, values) {
                                                const labelIndex = Math.floor(value);  // Assuming your x values align with the index
                                                return labels[labelIndex] || '';       // Return corresponding label or empty string
                                            },
                                            stepSize: 1, // Set step size to 1 to match your data points
                                        }
                                    },
                                    y: {
                                        title: {
                                            display: true,
                                            text: 'Value'
                                        },
                                        beginAtZero: true
                                    }
                                },
                                plugins: {
                                    title: {
                                        display: true,
                                        text: selectedText,  // Set your desired chart title
                                        font: {
                                            size: 18   // You can set the font size
                                        },
                                        padding: {
                                            top: 10,
                                            bottom: 10
                                        }
                                    },
                                    tooltip: {
                                        callbacks: {
                                            label: function(tooltipItem) {
                                                const timestamp = tempDataPoints.find(point => point.x == tooltipItem.parsed.x)?.t || null;
                                                // Return only the custom tooltip data
                                                return `Timestamp: ${timestamp}, Value: ${tooltipItem.parsed.y}`;
                                            },
                                            // To completely hide the default Y-axis value
                                            title: function() {
                                                return ''; // Hide the title
                                            }
                                        }
                                    }
                                }
                            }
                        });
                        return wrapper;
                    };

                    if (!result || result.length === 0) {
                        outputDiv.innerHTML = 'No data found.';
                    } else {
                        const table = createTable(result);
                        const graph = createGraph(result);
                        outputDiv.innerHTML = '';
                        outputGraphDiv.innerHTML = '';
                        outputGraphDiv.appendChild(graph);
                        outputDiv.appendChild(table);
                        outputDiv.dataset.result = JSON.stringify(result); // Store result for export
                    }
                    document.getElementById('loading-screen').style.display = 'none';
                } catch (error) {
                    console.error('Error occurred:', error);
                    outputDiv.innerHTML = 'Error: ' + error.message;
                }
            };

            const exportToCSV = (data) => {
                const selectElement = document.getElementById('data-select');
                const selectedOption = selectElement.options[selectElement.selectedIndex];
                const selectedText = selectedOption.text;
                const csvRows = [];
                const headers = Object.keys(data[0]);
                csvRows.push(headers.join(','));
                for (const row of data) {
                    const values = headers.map(header => {
                        const escaped = ('' + row[header]).replace(/"/g, '\\"');
                        return `"${escaped}"`;
                    });
                    csvRows.push(values.join(','));
                }

                const blob = new Blob([csvRows.join('\n')], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.setAttribute('href', url);
                a.setAttribute('download', selectedText + '.csv');
                a.click();
            };

            const exportToPDF = (data) => {
                const selectElement = document.getElementById('data-select');
                const selectedOption = selectElement.options[selectElement.selectedIndex];
                const selectedText = selectedOption.text;
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();

                // Convert the table data into arrays for jsPDF's autoTable
                const headers = Object.keys(data[0]);
                const rows = data.map(item => headers.map(header => item[header]));

                // Select the div element with the id "statistic-graph"
                const statisticGraphDiv = document.getElementById('statistic-graph');

                if (statisticGraphDiv) {
                    // Use html2canvas to convert the div to an image
                    html2canvas(statisticGraphDiv).then((canvas) => {
                        const imgData = canvas.toDataURL('image/png');

                        // Calculate the width and height for the image
                        const imgWidth = 190; // Width in mm (A4 paper width minus margins)
                        const imgHeight = (canvas.height * imgWidth) / canvas.width; // Maintain aspect ratio

                        // Add the image to the PDF at the top (10, 10 is the starting point)
                        doc.addImage(imgData, 'PNG', 10, 10, imgWidth, imgHeight);

                        // Add the table below the image
                        doc.autoTable({
                            head: [headers],
                            body: rows,
                            startY: 10 + imgHeight + 10, // Position the table 10mm below the image
                        });

                        // Save the PDF after everything is added
                        doc.save(selectedText + '.pdf');
                    });
                } else {
                    // If there's no graph, just add the table
                    doc.autoTable({
                        head: [headers],
                        body: rows,
                    });

                    doc.save(selectedText + '.pdf');
                }
            };

            document.getElementById('export-pdf').addEventListener('click', () => {
                let data = JSON.parse(outputDiv.dataset.result);
                console.log(data);

                // Convert the "time@timestamp" values to a readable date format
                data = data.map(row => {
                    if (row['Timestamp']) {
                        const date = new Date(row['Timestamp'] * 1000); // Convert to milliseconds
                        row['Timestamp'] = date.toLocaleString('en-US'); // Format to MM/DD/YYYY, HH:MM:SS AM/PM
                    }

                    return row;
                });

                exportToPDF(data);
            });


            document.getElementById('export-csv').addEventListener('click', () => {
                let data = JSON.parse(outputDiv.dataset.result);
                // Convert the "time@timestamp" values to a readable date format
                data = data.map(row => {
                    if (row['Timestamp']) {
                        const date = new Date(row['Timestamp'] * 1000); // Convert to milliseconds
                        row['Timestamp'] = date.toLocaleString('en-US'); // Format to MM/DD/YYYY, HH:MM:SS AM/PM
                    }

                    return row;
                });

                exportToCSV(data);
            });


            document.getElementById('btn__get-graph').addEventListener('click', async() => {
                await getTableData();
            });
            // Get all radio buttons and the period-from-to section
            const radioButtons = document.querySelectorAll('input[name="period"]');
            const periodFromTo = document.getElementById('period-from-to');

            // Add event listener to each radio button
            radioButtons.forEach(radio => {
                radio.addEventListener('change', async function() {
                    // Show the period-from-to section if Custom is selected, otherwise hide it
                    if (this.value === 'Custom') {
                        periodFromTo.style.display = 'table-row'; // Show the row
                    } else {
                        periodFromTo.style.display = 'none'; // Hide the row
                    }

                    await getTableData();
                });
            });
    </script>
</body>
</html>
